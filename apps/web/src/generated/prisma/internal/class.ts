/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ğŸ›‘ Under no circumstances should you import this file directly! ğŸ›‘
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from "@prisma/client/runtime/client";
import type * as Prisma from "./prismaNamespace";

const config: runtime.GetPrismaClientConfig = {
  previewFeatures: [],
  clientVersion: "7.2.0",
  engineVersion: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3",
  activeProvider: "postgresql",
  inlineSchema:
    '// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?\n// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init\n\ngenerator client {\n  provider = "prisma-client"\n  output   = "../src/generated/prisma"\n}\n\ndatasource db {\n  provider = "postgresql"\n}\n\nmodel User {\n  id            String           @id @default(uuid())\n  walletAddress String           @unique // ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆ0x...å½¢å¼ï¼‰\n  name          String? // ãƒ¦ãƒ¼ã‚¶ãƒ¼åï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰\n  email         String? // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰\n  avatar        String? // ã‚¢ãƒã‚¿ãƒ¼ç”»åƒURLï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰\n  metadata      Json? // è¿½åŠ æƒ…å ±ï¼ˆJSONï¼‰\n  payments      PaymentHistory[]\n  createdAt     DateTime         @default(now())\n  updatedAt     DateTime         @updatedAt\n\n  @@index([walletAddress])\n  @@map("users")\n}\n\nmodel Merchant {\n  id        String    @id @default(uuid())\n  name      String\n  createdAt DateTime  @default(now())\n  updatedAt DateTime  @updatedAt\n  products  Product[]\n\n  @@map("merchants")\n}\n\nmodel Product {\n  id          String           @id @default(uuid())\n  name        String\n  description String\n  price       BigInt // weiå˜ä½ã®ä¾¡æ ¼ï¼ˆ6æ¡å°æ•°ç‚¹æƒ³å®šï¼‰\n  currency    String           @default("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913") // ãƒˆãƒ¼ã‚¯ãƒ³ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹\n  stockStatus String           @default("in_stock") // åœ¨åº«ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆ"in_stock" | "low_stock" | "out_of_stock"ï¼‰\n  imageUrl    String? // å•†å“ç”»åƒURL\n  category    String? // ã‚«ãƒ†ã‚´ãƒªï¼ˆä¾‹: "cat_food", "dog_food"ãªã©ï¼‰\n  attributes  Json? // ã‚«ãƒ†ã‚´ãƒªã”ã¨ã®å±æ€§ï¼ˆã‚­ãƒ¼ãƒ»ãƒãƒªãƒ¥ãƒ¼ã®ãƒãƒƒãƒ—ï¼‰\n  merchantId  String\n  merchant    Merchant         @relation(fields: [merchantId], references: [id], onDelete: Cascade)\n  payments    PaymentHistory[]\n  createdAt   DateTime         @default(now())\n  updatedAt   DateTime         @updatedAt\n\n  @@map("products")\n}\n\nmodel PaymentHistory {\n  id          String    @id @default(uuid())\n  paymentId   String    @unique // x402æ±ºæ¸ˆIDï¼ˆ0x...å½¢å¼ï¼‰\n  payer       String // æ”¯æ‰•ã„è€…ã®ã‚¢ãƒ‰ãƒ¬ã‚¹\n  userId      String? // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰\n  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)\n  recipient   String // å—å–äººã®ã‚¢ãƒ‰ãƒ¬ã‚¹\n  amount      String // æ±ºæ¸ˆé‡‘é¡ï¼ˆweiå˜ä½ã®æ–‡å­—åˆ—ï¼‰\n  asset       String // ãƒˆãƒ¼ã‚¯ãƒ³ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹\n  network     String // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯åï¼ˆä¾‹: "base", "localhost"ï¼‰\n  chainId     Int // ãƒã‚§ãƒ¼ãƒ³ID\n  status      String    @default("pending") // pending, settled, failed\n  txHash      String? // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ãƒãƒƒã‚·ãƒ¥ï¼ˆsettleå¾Œï¼‰\n  blockNumber String? // ãƒ–ãƒ­ãƒƒã‚¯ç•ªå·ï¼ˆsettleå¾Œï¼‰\n  orderId     String? // æ³¨æ–‡IDï¼ˆå•†å“è³¼å…¥ã®å ´åˆï¼‰\n  productId   String? // å•†å“IDï¼ˆå•†å“è³¼å…¥ã®å ´åˆï¼‰\n  product     Product?  @relation(fields: [productId], references: [id], onDelete: SetNull)\n  metadata    Json? // è¿½åŠ æƒ…å ±ï¼ˆJSONï¼‰\n  createdAt   DateTime  @default(now())\n  settledAt   DateTime? // æ±ºæ¸ˆå®Œäº†æ—¥æ™‚\n\n  @@index([paymentId])\n  @@index([payer])\n  @@index([userId])\n  @@index([productId])\n  @@index([status])\n  @@index([createdAt])\n  @@map("payment_history")\n}\n',
  runtimeDataModel: {
    models: {},
    enums: {},
    types: {},
  },
};

config.runtimeDataModel = JSON.parse(
  '{"models":{"User":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"walletAddress","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"email","kind":"scalar","type":"String"},{"name":"avatar","kind":"scalar","type":"String"},{"name":"metadata","kind":"scalar","type":"Json"},{"name":"payments","kind":"object","type":"PaymentHistory","relationName":"PaymentHistoryToUser"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"}],"dbName":"users"},"Merchant":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"products","kind":"object","type":"Product","relationName":"MerchantToProduct"}],"dbName":"merchants"},"Product":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"price","kind":"scalar","type":"BigInt"},{"name":"currency","kind":"scalar","type":"String"},{"name":"stockStatus","kind":"scalar","type":"String"},{"name":"imageUrl","kind":"scalar","type":"String"},{"name":"category","kind":"scalar","type":"String"},{"name":"attributes","kind":"scalar","type":"Json"},{"name":"merchantId","kind":"scalar","type":"String"},{"name":"merchant","kind":"object","type":"Merchant","relationName":"MerchantToProduct"},{"name":"payments","kind":"object","type":"PaymentHistory","relationName":"PaymentHistoryToProduct"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"}],"dbName":"products"},"PaymentHistory":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"paymentId","kind":"scalar","type":"String"},{"name":"payer","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"user","kind":"object","type":"User","relationName":"PaymentHistoryToUser"},{"name":"recipient","kind":"scalar","type":"String"},{"name":"amount","kind":"scalar","type":"String"},{"name":"asset","kind":"scalar","type":"String"},{"name":"network","kind":"scalar","type":"String"},{"name":"chainId","kind":"scalar","type":"Int"},{"name":"status","kind":"scalar","type":"String"},{"name":"txHash","kind":"scalar","type":"String"},{"name":"blockNumber","kind":"scalar","type":"String"},{"name":"orderId","kind":"scalar","type":"String"},{"name":"productId","kind":"scalar","type":"String"},{"name":"product","kind":"object","type":"Product","relationName":"PaymentHistoryToProduct"},{"name":"metadata","kind":"scalar","type":"Json"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"settledAt","kind":"scalar","type":"DateTime"}],"dbName":"payment_history"}},"enums":{},"types":{}}',
);

async function decodeBase64AsWasm(
  wasmBase64: string,
): Promise<WebAssembly.Module> {
  const { Buffer } = await import("node:buffer");
  const wasmArray = Buffer.from(wasmBase64, "base64");
  return new WebAssembly.Module(wasmArray);
}

config.compilerWasm = {
  getRuntime: async () =>
    await import("@prisma/client/runtime/query_compiler_bg.postgresql.mjs"),

  getQueryCompilerWasmModule: async () => {
    const { wasm } = await import(
      "@prisma/client/runtime/query_compiler_bg.postgresql.wasm-base64.mjs"
    );
    return await decodeBase64AsWasm(wasm);
  },
};

export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
  "log" extends keyof ClientOptions
    ? ClientOptions["log"] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions["log"]>
      : never
    : never;

export interface PrismaClientConstructor {
  /**
   * ## Prisma Client
   *
   * Type-safe database client for TypeScript
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  new <
    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    LogOpts extends LogOptions<Options> = LogOptions<Options>,
    OmitOpts extends Prisma.PrismaClientOptions["omit"] = Options extends {
      omit: infer U;
    }
      ? U
      : Prisma.PrismaClientOptions["omit"],
    ExtArgs extends
      runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  >(
    options: Prisma.Subset<Options, Prisma.PrismaClientOptions>,
  ): PrismaClient<LogOpts, OmitOpts, ExtArgs>;
}

/**
 * ## Prisma Client
 *
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */

export interface PrismaClient<
  in LogOpts extends Prisma.LogLevel = never,
  in out OmitOpts extends Prisma.PrismaClientOptions["omit"] = undefined,
  in out ExtArgs extends
    runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["other"] };

  $on<V extends LogOpts>(
    eventType: V,
    callback: (
      event: V extends "query" ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): runtime.Types.Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): runtime.Types.Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => runtime.Types.Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): runtime.Types.Utils.JsPromise<R>;

  $extends: runtime.Types.Extensions.ExtendsHook<
    "extends",
    Prisma.TypeMapCb<OmitOpts>,
    ExtArgs,
    runtime.Types.Utils.Call<
      Prisma.TypeMapCb<OmitOpts>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.merchant`: Exposes CRUD operations for the **Merchant** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Merchants
   * const merchants = await prisma.merchant.findMany()
   * ```
   */
  get merchant(): Prisma.MerchantDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Products
   * const products = await prisma.product.findMany()
   * ```
   */
  get product(): Prisma.ProductDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.paymentHistory`: Exposes CRUD operations for the **PaymentHistory** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PaymentHistories
   * const paymentHistories = await prisma.paymentHistory.findMany()
   * ```
   */
  get paymentHistory(): Prisma.PaymentHistoryDelegate<
    ExtArgs,
    { omit: OmitOpts }
  >;
}

export function getPrismaClientClass(): PrismaClientConstructor {
  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor;
}
